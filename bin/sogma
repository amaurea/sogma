#!/usr/bin/env python
import numpy as np, os, time, sys
from pixell import config, enmap, utils, mpi, colors, bench
from sogma import logging, mapmaking, loading, tiling, nmat, device, gutils
# Have to do all imports that could contain configuration before
# building config.ArgumentParser because these may define variables.
# This means we can't bail out early when called with wrong arguments;
# we have to wait for potentially slow imports first. Oh well.
parser = config.ArgumentParser("sogma")
parser.add_argument("area")
parser.add_argument("odir")
parser.add_argument("-C", "--context", type=str, default="lat", help="Either a config.yaml, context.yaml or a telescope name, like lat, satp1, etc.. The most general is config.yaml, which works with both the sofast and soslow loaders. Using just a context only works with sofast, and must be a context that includes the preprocess database. Telescope names expand to the default preprocess context using $SOPATH, which should point to the SO top-level directory (the one that contains the metadata directory).")
parser.add_argument("-Q", "--query",   type=str, default=None)
parser.add_argument("-p", "--prefix",  type=str, default=None)
parser.add_argument("-v", "--verbose", action="count", default=1)
parser.add_argument("-q", "--quiet",   action="count", default=0)
parser.add_argument("-L", "--loader",  type=str, default="auto")
parser.add_argument("-D", "--device",  type=str, default="auto")
parser.add_argument("-I", "--maxiter", type=int, default=500)
parser.add_argument(      "--maxerr",  type=float, default=1e-7)
parser.add_argument("-m", "--mode",    type=str, default="full")
parser.add_argument("-a", "--autocrop",   action="store_true")
parser.add_argument("-N", "--nmat",    type=str, default="new")
parser.add_argument(      "--ignore",  type=str, default="recover")
parser.add_argument("-d", "--dump",    type=str, default="10,20,50,100")
parser.add_argument("-j", "--joint",   type=str, default="obs")
parser.add_argument("-s", "--split",   type=float, default=0.75, help="Split obs-groups in time to keep them smaller than this many giga-samples. Larger groups use more memory. Small groups have more edge effects and may be slower to read in.")
parser.add_argument("-c", "--cont",    action="store_true")
parser.add_argument(      "--sys",     type=str, default="cel")
parser.add_argument("-o", "--output",  type=str, default="auto")
parser.add_argument(      "--sel",     type=str, default=":")
args = parser.parse_args()

# Should some of this be factored out into an
# SO-specific mapmaker class?

if   args.mode in ["individual","depth1"]: separate = True
elif args.mode in ["full", "dump"]:        separate = False
else: raise ValueError("Unknown mode '%s'" % (str(args.mode)))
comm_all   = mpi.COMM_WORLD
comm_per   = mpi.COMM_SELF if separate else mpi.COMM_WORLD
dtype_tod  = np.float32
dtype_map  = np.float32
shape, wcs = enmap.read_map_geometry(args.area)
dump       = [int(w) for w in args.dump.split(",")]
# Set up our device
dev = device.get_device(args.device)
# Set up our logging
verbosity  = args.verbose-args.quiet
L = logging.Logger(dev, id=comm_all.rank, level=verbosity, fmt="{id:3d} {t:10.6f} {mem:10.6f} {dmem_pools:10.6f} {dmem_rest:10.6f} {dmem_unknown:10.6f} {msg:s}").setdefault()
bench.set_verbose(verbosity >= 3)
L.print("Init", level=0, id=0, color=colors.lgreen)
# Benchmarking
bench.set_tfun(dev.time)
# Set up our memory pools. This shouldn't be necessary if I make
# the interface a bit nicer
dev.pools.want("tod", "ft", "pointing", "plan", "nmat_work", "cut")
# Set up our data loader
loader  = loading.Loader(args.context, type=args.loader, dev=dev)
obsinfo = loader.query(args.query)
if len(obsinfo) == 0:
	L.print("No tods selected. Quitting", level=0, id=0, color=colors.red)
	sys.exit(1)
# joint gives subobs to map jointly. It has entries
# .names[ngroup]     Name of each group
# .groups[ngroup][:] Indices into obsinfo for ach group member
# .bands[nband]      List of bands involved
# .joint     False if joint mapmaking isn't actually enabled. Groups will just be one subobs each
joint   = loader.group_obs(obsinfo, mode=args.joint)
joint   = gutils.time_split(obsinfo, joint, maxsize=args.split*1e9)
# group selection. Sadly this can't be done with the query-level selection, as that
# happens before grouping.
jinds   = eval("list(range(%d))[%s]" % (len(joint.groups),args.sel))
joint   = gutils.select_groups(joint, jinds)
ngroup  = len(joint.groups)
if joint.joint:
	bandmsg = ",".join(joint.bands)
	if len(joint.nullbands) > 0:
		bandmsg += " null " + ",".join(joint.nullbands)
	L.print("Mapping %d tod-groups across %s with %d mpi tasks" % (ngroup, bandmsg, comm_all.size), level=0, id=0, color=colors.lgreen)
else:
	L.print("Mapping %d tods with %d mpi tasks" % (ngroup, comm_all.size), level=0, id=0, color=colors.lgreen)
prefix = args.odir + "/"
if args.prefix: prefix += args.prefix + "_"
utils.mkdir(args.odir)
# Write out our arguments
if comm_all.rank == 0:
	with open(prefix + "args.txt", "w") as ofile:
		ofile.write(" ".join(sys.argv) + "\n")
# Set up what to output for each signal. This is limited and hacky,
# but would have to be rewritten in any case if we move to arbitrary-signal
# support. For now, any field mentioned refers to SignalMap, except for "cut",
# which enables cut output. "auto" sets up output of map and ivar for full maps,
# and adds a time-map for short-duration maps.
map_out, cut_out, info_out = [], [], True
for name in args.output.split(","):
	if name == "auto":
		map_out += ["map","ivar"]
		if args.mode in ["depth1","individual"]: map_out += ["time"]
	elif name == "cut": cut_out += ["map"]
	else:               map_out += [name]
# Set up the signals we will solve for
if joint.joint:
	signal_map = mapmaking.SignalMapMulti(shape, wcs, joint.bands, comm_per, dev=dev, dtype=np.float32, sys=args.sys, autocrop=args.autocrop, outputs=map_out)
else:
	signal_map = mapmaking.SignalMap(shape, wcs, comm_per, dev=dev, dtype=np.float32, sys=args.sys, autocrop=args.autocrop)
signal_cut = mapmaking.SignalCutPoly(comm_per, dev=dev, outputs=cut_out)
signal_info= mapmaking.SignalInfo(comm_per, dev=dev)
signals    = [signal_cut, signal_map, signal_info]
# Set up the noise model
if   args.nmat == "jon":    noise_model = nmat.NmatDetvecs(dev=dev)
elif args.nmat == "jond":   noise_model = nmat.NmatDetvecs(dev=dev, downweight=[1e-4, 0.25, 0.50])
elif args.nmat == "uncorr": noise_model = nmat.NmatUncorr(dev=dev)
elif args.nmat == "debug":  noise_model = nmat.NmatDebug(dev=dev)
elif args.nmat == "none":   noise_model = nmat.Nmat(dev=dev)
elif args.nmat == "new":    noise_model = nmat.NmatAdaptive(dev=dev)
elif args.nmat == "newb":   noise_model = nmat.NmatAdaptive(dev=dev, maxmodes=200)
else: raise ValueError("Unrecognized noise model '%s'" % (str(args.nmat)))
# Set up the mapmaker
mapmaker = mapmaking.MLMapmaker(signals=signals, dtype=dtype_tod, verbose=True, noise_model=noise_model, dev=dev)

if   args.mode == "full":
	mapmaking.make_map(mapmaker, loader, obsinfo, comm_all, joint=joint, prefix=prefix, dump=dump, maxiter=args.maxiter, maxerr=args.maxerr, ignore=args.ignore, cont=args.cont)
elif args.mode == "individual":
	mapmaking.make_maps_perobs(mapmaker, loader, obsinfo, comm_all, comm_per, joint=joint, prefix=prefix, dump=dump, maxiter=args.maxiter, maxerr=args.maxerr, ignore=args.ignore, cont=args.cont)
elif args.mode == "depth1":
	mapmaking.make_maps_depth1(mapmaker, loader, obsinfo, comm_all, comm_per, joint=joint, prefix=prefix, dump=dump, maxiter=args.maxiter, maxerr=args.maxerr, ignore=args.ignore, cont=args.cont)
elif args.mode == "dump":
	mapmaking.dump_tod(loader, obsinfo, noise_model, comm_all, dev=dev, joint=joint, prefix=prefix, ignore=args.ignore)
else: raise ValueError("Unknown mode '%s'" % str(args.mode))
