#!/usr/bin/env python
import numpy as np, os, time, sys
from pixell import config, enmap, utils, mpi, colors, bench
from sogma import logging, mapmaking, loading, tiling, nmat, device, gutils, soeph
# for its config
from sogma.loaders import sofast
# Have to do all imports that could contain configuration before
# building config.ArgumentParser because these may define variables.
# This means we can't bail out early when called with wrong arguments;
# we have to wait for potentially slow imports first. Oh well.
parser = config.ArgumentParser("sogma")
parser.add_argument("planet")
parser.add_argument("area")
parser.add_argument("odir")
parser.add_argument("-C", "--context", type=str, default="lat", help="Either a config.yaml, context.yaml or a telescope name, like lat, satp1, etc.. The most general is config.yaml, which works with both the sofast and soslow loaders. Using just a context only works with sofast, and must be a context that includes the preprocess database. Telescope names expand to the default preprocess context using $SOPATH, which should point to the SO top-level directory (the one that contains the metadata directory).")
parser.add_argument("-r", "--mask-rad",type=float, default=30, help="The atmospheric context region is this far away from the planet, in arcmin")
parser.add_argument("-Q", "--query",   type=str, default=None)
parser.add_argument("-p", "--prefix",  type=str, default=None)
parser.add_argument("-v", "--verbose", action="count", default=1)
parser.add_argument("-q", "--quiet",   action="count", default=0)
parser.add_argument("-L", "--loader",  type=str, default="auto")
parser.add_argument("-D", "--device",  type=str, default="auto")
parser.add_argument(      "--ignore",  type=str, default="recover")
parser.add_argument("-j", "--joint",   type=str, default="obs")
parser.add_argument("-s", "--split",   type=float, default=0.75, help="Split obs-groups in time to keep them smaller than this many giga-samples. Larger groups use more memory. Small groups have more edge effects and may be slower to read in.")
parser.add_argument(      "--tsplit",  type=float, default=None, help="Split obs-groups in time to keep them shorter than this many seconds. See also --split")
parser.add_argument("-c", "--cont",    action="store_true")
parser.add_argument(      "--sel",     type=str, default=":")
args = parser.parse_args()

comm_all   = mpi.COMM_WORLD
comm_per   = mpi.COMM_SELF
dtype_tod  = np.float32
dtype_map  = np.float32
shape, wcs = enmap.read_map_geometry(args.area)
mask_rad   = args.mask_rad*utils.arcmin
# Set up our device
dev = device.get_device(args.device)
# Set up our logging
verbosity  = args.verbose-args.quiet
L = logging.Logger(dev, id=comm_all.rank, level=verbosity, fmt="{id:3d} {t:10.6f} {mem:10.6f} {dmem_pools:10.6f} {dmem_rest:10.6f} {dmem_unknown:10.6f} {msg:s}").setdefault()
bench.set_verbose(verbosity >= 3)
L.print("Init", level=0, id=0, color=colors.lgreen)
# Benchmarking
bench.set_tfun(dev.time)
# Register ephemerides
soeph.setup()
# Set up our data loader
loader  = loading.Loader(args.context, type=args.loader, dev=dev)
obsinfo = loader.query(args.query)
if len(obsinfo) == 0:
	L.print("No tods selected. Quitting", level=0, id=0, color=colors.red)
	sys.exit(1)
# Define obs-groups
joint   = loader.group_obs(obsinfo, mode=args.joint)
joint   = gutils.time_split(obsinfo, joint, maxsize=args.split*1e9, maxdur=args.tsplit)
# group selection. Sadly this can't be done with the query-level selection, as that
# happens before grouping.
jinds   = eval("list(range(%d))[%s]" % (len(joint.groups),args.sel))
joint   = gutils.select_groups(joint, jinds)
ngroup  = len(joint.groups)
if joint.joint:
	bandmsg = ",".join(joint.bands)
	if len(joint.nullbands) > 0:
		bandmsg += " null " + ",".join(joint.nullbands)
	L.print("Mapping %d tod-groups across %s with %d mpi tasks" % (ngroup, bandmsg, comm_all.size), level=0, id=0, color=colors.lgreen)
else:
	L.print("Mapping %d tods with %d mpi tasks" % (ngroup, comm_all.size), level=0, id=0, color=colors.lgreen)
prefix = args.odir + "/"
if args.prefix: prefix += args.prefix + "_"
utils.mkdir(args.odir)
# Write out our arguments
if comm_all.rank == 0:
	with open(prefix + "args.txt", "w") as ofile:
		ofile.write(" ".join(sys.argv) + "\n")
# Set up our planet coordinate system
planet   = args.planet.lower()
sys      = "hor,on=%s" % planet
# Make sure we don't cut the thing we're trying to map!
planets  = [name.lower() for name in config.get("planet_list").split(",")]
planets  = [name for name in planets if name != planet]
config.set("planet_list", ",".join(planets))
# Don't bother cutting asteroids
config.set("object_cut",    "planets:5")
# Set up noise model
mask = enmap.zeros((3,)+shape[-3:], wcs, dtype_map)
mask[0] = mask.distance_from([0,0], rmax=mask_rad) < mask_rad
# Only safe to use buf="pointing" if we perform zero cg steps!
noise_model = nmat.PseudoNmatGapfill(mask=mask, sys=sys, buf="pointing", dev=dev)
# Set up the signals we will solve for
map_out = ["bin", "ivar"]
if joint.joint:
	signal_map = mapmaking.SignalMapMulti(shape, wcs, joint.bands, comm_per, dev=dev, dtype=dtype_map, sys=sys, outputs=map_out, precon="div")
else:
	signal_map = mapmaking.SignalMap(shape, wcs, comm_per, dev=dev, dtype=dtype_map, sys=sys, outputs=map_out, precon="div")
signals    = [signal_map]
# Setup mapmaker and make the maps
mapmaker = mapmaking.MLMapmaker(signals=signals, dtype=dtype_tod, verbose=True, noise_model=noise_model, dev=dev)
mapmaking.make_maps_perobs(mapmaker, loader, obsinfo, comm_all, comm_per, joint=joint, prefix=prefix, maxiter=0, ignore=args.ignore, cont=args.cont)
